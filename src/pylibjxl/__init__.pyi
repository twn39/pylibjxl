from typing import Any, Dict, Optional, Tuple, Union, overload, Literal
import numpy as np
import numpy.typing as npt
from pathlib import Path

# --- Native extension functions ---

def version() -> Dict[str, int]: ...
def decoder_version() -> int: ...
def encoder_version() -> int: ...

def encode(
    input: npt.NDArray[np.uint8],
    effort: int = 7,
    distance: float = 1.0,
    lossless: bool = False,
    exif: Optional[bytes] = None,
    xmp: Optional[bytes] = None,
    jumbf: Optional[bytes] = None,
) -> bytes: ...

@overload
def decode(data: bytes, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
@overload
def decode(data: bytes, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
@overload
def decode(data: bytes, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

def encode_jpeg(input: npt.NDArray[np.uint8], quality: int = 95) -> bytes: ...
def decode_jpeg(data: bytes) -> npt.NDArray[np.uint8]: ...

def jpeg_to_jxl(data: bytes, effort: int = 7) -> bytes: ...
def jxl_to_jpeg(data: bytes) -> bytes: ...

class _JXL:
    def __init__(self, effort: int = 7, distance: float = 1.0, lossless: bool = False) -> None: ...
    def encode(
        self,
        input: npt.NDArray[np.uint8],
        effort: Optional[int] = None,
        distance: Optional[float] = None,
        lossless: Optional[bool] = None,
        exif: Optional[bytes] = None,
        xmp: Optional[bytes] = None,
        jumbf: Optional[bytes] = None,
    ) -> bytes: ...
    
    @overload
    def decode(self, data: bytes, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
    @overload
    def decode(self, data: bytes, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
    @overload
    def decode(self, data: bytes, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

    def encode_jpeg(self, input: npt.NDArray[np.uint8], quality: int = 95) -> bytes: ...
    def decode_jpeg(self, data: bytes) -> npt.NDArray[np.uint8]: ...
    def jpeg_to_jxl(self, data: bytes, effort: Optional[int] = None) -> bytes: ...
    def jxl_to_jpeg(self, data: bytes) -> bytes: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def __enter__(self) -> "_JXL": ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

# --- Python wrapper functions and classes ---

async def encode_async(
    input: npt.NDArray[np.uint8],
    effort: int = 7,
    distance: float = 1.0,
    lossless: bool = False,
    *,
    exif: Optional[bytes] = None,
    xmp: Optional[bytes] = None,
    jumbf: Optional[bytes] = None,
) -> bytes: ...

@overload
async def decode_async(data: bytes, *, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
@overload
async def decode_async(data: bytes, *, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
@overload
async def decode_async(data: bytes, *, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

@overload
def read(path: Union[str, Path], *, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
@overload
def read(path: Union[str, Path], *, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
@overload
def read(path: Union[str, Path], *, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

def write(
    path: Union[str, Path],
    image: npt.NDArray[np.uint8],
    effort: int = 7,
    distance: float = 1.0,
    lossless: bool = False,
    *,
    exif: Optional[bytes] = None,
    xmp: Optional[bytes] = None,
    jumbf: Optional[bytes] = None,
) -> None: ...

@overload
async def read_async(path: Union[str, Path], *, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
@overload
async def read_async(path: Union[str, Path], *, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
@overload
async def read_async(path: Union[str, Path], *, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

async def write_async(
    path: Union[str, Path],
    image: npt.NDArray[np.uint8],
    effort: int = 7,
    distance: float = 1.0,
    lossless: bool = False,
    *,
    exif: Optional[bytes] = None,
    xmp: Optional[bytes] = None,
    jumbf: Optional[bytes] = None,
) -> None: ...

class JXL(_JXL):
    @overload
    def read(self, path: Union[str, Path], *, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
    @overload
    def read(self, path: Union[str, Path], *, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
    @overload
    def read(self, path: Union[str, Path], *, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

    def write(
        self,
        path: Union[str, Path],
        image: npt.NDArray[np.uint8],
        effort: Optional[int] = None,
        distance: Optional[float] = None,
        lossless: Optional[bool] = None,
        *,
        exif: Optional[bytes] = None,
        xmp: Optional[bytes] = None,
        jumbf: Optional[bytes] = None,
    ) -> None: ...

    def read_jpeg(self, path: Union[str, Path]) -> npt.NDArray[np.uint8]: ...
    def write_jpeg(self, path: Union[str, Path], image: npt.NDArray[np.uint8], quality: int = 95) -> None: ...
    def convert_jpeg_to_jxl(self, jpeg_path: Union[str, Path], jxl_path: Union[str, Path], effort: Optional[int] = None) -> None: ...
    def convert_jxl_to_jpeg(self, jxl_path: Union[str, Path], jpeg_path: Union[str, Path]) -> None: ...
    def __enter__(self) -> "JXL": ...

class AsyncJXL(_JXL):
    async def __aenter__(self) -> "AsyncJXL": ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    
    async def encode_async(
        self,
        input: npt.NDArray[np.uint8],
        effort: Optional[int] = None,
        distance: Optional[float] = None,
        lossless: Optional[bool] = None,
        *,
        exif: Optional[bytes] = None,
        xmp: Optional[bytes] = None,
        jumbf: Optional[bytes] = None,
    ) -> bytes: ...

    @overload
    async def decode_async(self, data: bytes, *, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
    @overload
    async def decode_async(self, data: bytes, *, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
    @overload
    async def decode_async(self, data: bytes, *, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

    @overload
    async def read_async(self, path: Union[str, Path], *, metadata: Literal[False] = False) -> npt.NDArray[np.uint8]: ...
    @overload
    async def read_async(self, path: Union[str, Path], *, metadata: Literal[True]) -> Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]: ...
    @overload
    async def read_async(self, path: Union[str, Path], *, metadata: bool) -> Union[npt.NDArray[np.uint8], Tuple[npt.NDArray[np.uint8], Dict[str, bytes]]]: ...

    async def write_async(
        self,
        path: Union[str, Path],
        image: npt.NDArray[np.uint8],
        effort: Optional[int] = None,
        distance: Optional[float] = None,
        lossless: Optional[bool] = None,
    ) -> None: ...

    async def encode_jpeg_async(self, input: npt.NDArray[np.uint8], quality: int = 95) -> bytes: ...
    async def decode_jpeg_async(self, data: bytes) -> npt.NDArray[np.uint8]: ...
    async def read_jpeg_async(self, path: Union[str, Path]) -> npt.NDArray[np.uint8]: ...
    async def write_jpeg_async(self, path: Union[str, Path], image: npt.NDArray[np.uint8], quality: int = 95) -> None: ...
    async def jpeg_to_jxl_async(self, data: bytes, effort: Optional[int] = None) -> bytes: ...
    async def jxl_to_jpeg_async(self, data: bytes) -> bytes: ...
    async def convert_jpeg_to_jxl_async(self, jpeg_path: Union[str, Path], jxl_path: Union[str, Path], effort: Optional[int] = None) -> None: ...
    async def convert_jxl_to_jpeg_async(self, jxl_path: Union[str, Path], jpeg_path: Union[str, Path]) -> None: ...

async def encode_jpeg_async(input: npt.NDArray[np.uint8], quality: int = 95) -> bytes: ...
async def decode_jpeg_async(data: bytes) -> npt.NDArray[np.uint8]: ...
async def jpeg_to_jxl_async(data: bytes, effort: int = 7) -> bytes: ...
async def jxl_to_jpeg_async(data: bytes) -> bytes: ...

def read_jpeg(path: Union[str, Path]) -> npt.NDArray[np.uint8]: ...
def write_jpeg(path: Union[str, Path], image: npt.NDArray[np.uint8], quality: int = 95) -> None: ...
async def read_jpeg_async(path: Union[str, Path]) -> npt.NDArray[np.uint8]: ...
async def write_jpeg_async(path: Union[str, Path], image: npt.NDArray[np.uint8], quality: int = 95) -> None: ...

def convert_jpeg_to_jxl(jpeg_path: Union[str, Path], jxl_path: Union[str, Path], effort: int = 7) -> None: ...
def convert_jxl_to_jpeg(jxl_path: Union[str, Path], jpeg_path: Union[str, Path]) -> None: ...
async def convert_jpeg_to_jxl_async(jpeg_path: Union[str, Path], jxl_path: Union[str, Path], effort: int = 7) -> None: ...
async def convert_jxl_to_jpeg_async(jxl_path: Union[str, Path], jpeg_path: Union[str, Path]) -> None: ...
